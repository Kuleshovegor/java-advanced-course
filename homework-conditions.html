<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Технологии Java :: Домашние задания</title><link href="/design/main.css" type="text/css" rel="stylesheet"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link href="./../../plan.css" type="text/css" rel="stylesheet"><script type="text/javascript">var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-37693764-1"]);_gaq.push(["_setDomainName","kgeorgiy.info"]);_gaq.push(["_trackPageview"]);(function(){var a=document.createElement("script");a.type="text/javascript";a.async=!0;a.src=("https:"==document.location.protocol?"https://ssl":"http://www")+".google-analytics.com/ga.js";var b=document.getElementsByTagName("script")[0];b.parentNode.insertBefore(a,b)})();</script></head><body><table id="header"><tr><td id="breadcrumbs"><a href="./../../">ГК</a> / <a href="./../">Материалы курсов</a> / <a href="./">Технологии Java</a> / </td></tr><tr><td id="title">Домашние задания</td></tr></table><table id="body"><tr><td id="main"><h3 id="homework-walk">Домашнее задание 1. Обход файлов</h3><ol><li>
    Разработайте класс <tt>Walk</tt>, осуществляющий подсчет хеш-сумм файлов.
    <ol><li>
        Формат запуска
        <pre>java Walk &lt;входной файл&gt; &lt;выходной файл&gt;</pre></li><li>
        Входной файл содержит список файлов, которые требуется обойти.
    </li><li>
        Выходной файл должен содержать по одной строке для каждого
        файла. Формат строки:
        <pre>&lt;шестнадцатеричная хеш-сумма&gt; &lt;путь к файлу&gt;</pre></li><li>
        Для подсчета хеш-суммы используйте
        64-битную версию алгоритма <a href="https://en.wikipedia.org/wiki/PJW_hash_function">PJW</a>.

    </li><li>
        Если при чтении файла возникают ошибки, укажите в качестве
        его хеш-суммы <tt>0000000000000000</tt>.
    </li><li>
        Кодировка входного и выходного файлов &mdash; UTF-8.
    </li><li>
        Если родительская директория выходного файла
        не существует, то соответствующий путь надо создать.
    </li><li>
        Размеры файлов могут превышать размер оперативной памяти.
    </li><li><p>Пример</p><p>Входной файл</p><pre>
    samples/1
    samples/12
    samples/123
    samples/1234
    samples/1
    samples/binary
    samples/no-such-file
                    </pre><p>Выходной файл</p><pre>
    0000000000000031 samples/1
    0000000000003132 samples/12
    0000000000313233 samples/123
    0000000031323334 samples/1234
    0000000000000031 samples/1
    005501015554abff samples/binary
    0000000000000000 samples/no-such-file
                    </pre></li></ol></li><li>
    Сложный вариант:
    <ol><li>
        Разработайте класс <tt>RecursiveWalk</tt>,
        осуществляющий подсчет хеш-сумм файлов в
        директориях
    </li><li>
        Входной файл содержит список файлов и директорий,
        которые требуется обойти. Обход директорий осуществляется
        рекурсивно.
    </li><li><p>Пример</p><p>Входной файл</p><pre>
    samples/binary
    samples
    samples/no-such-file
                    </pre><p>Выходной файл</p><pre>
    005501015554abff samples/binary
    0000000000000031 samples/1
    0000000000003132 samples/12
    0000000000313233 samples/123
    0000000031323334 samples/1234
    005501015554abff samples/binary
    0000000000000000 samples/no-such-file
                    </pre></li></ol></li><li>
    При выполнении задания следует обратить внимание на:
    <ul><li>
        Дизайн и обработку исключений, диагностику ошибок.
    </li><li>
        Программа должна корректно завершаться даже в случае ошибки.
    </li><li>
        Корректная работа с вводом-выводом.
    </li><li>
        Отсутствие утечки ресурсов.
    </li></ul></li><li>
    Требования к оформлению задания.
    <ul><li>
        Проверяется исходный код задания.
    </li><li>
        Весь код должен находиться в пакете
        <tt>info.kgeorgiy.ja.фамилия.walk</tt>.
    </li></ul></li></ol><p><a href="https://www.kgeorgiy.info/git/geo/java-advanced-2021">Тесты к домашним заданиям</a></p><h3 id="homework-arrayset">Домашнее задание 2. Множество на массиве</h3><ol><li>
    Разработайте класс <tt>ArraySet</tt>,
    реализующие неизменяемое упорядоченное множество.
    <ul><li>
        Класс <tt>ArraySet</tt> должен реализовывать
        интерфейс <tt>SortedSet</tt> (простой вариант)
        или <tt>NavigableSet</tt> (сложный вариант).
    </li><li>
        Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
    </li></ul></li><li>
    При выполнении задания следует обратить внимание на:
    <ul><li>
        Применение стандартных коллекций.
    </li><li>
        Избавление от повторяющегося кода.
    </li></ul></li></ol><h3 id="homework-student">Домашнее задание 3. Студенты</h3><ol><li>
    Разработайте класс <code>StudentDB</code>,
    осуществляющий поиск по базе данных студентов.
    <ul><li>
        Класс <code>StudentDB</code> должен реализовывать
        интерфейс <code>StudentQuery</code> (простой вариант)
        или <code>GroupQuery</code> (сложный вариант).
    </li><li>
        Каждый метод должен состоять из ровно одного оператора.
        При этом длинные операторы надо разбивать на несколько строк.
    </li></ul></li><li>
    При выполнении задания следует обратить внимание на:
    <ul><li>
        применение лямбда-выражений и потоков;
    </li><li>
        избавление от повторяющегося кода.
    </li></ul></li></ol><h3 id="homework-implementor">Домашнее задание 4. Implementor</h3><ol><li>
    Реализуйте класс <code>Implementor</code>, который будет генерировать
    реализации классов и интерфейсов.
    <ul><li>
        Аргумент командной строки: полное имя класса/интерфейса, для
        которого требуется сгенерировать реализацию.
    </li><li>
        В результате работы должен быть сгенерирован java-код класса с суффиксом
        <code>Impl</code>, расширяющий (реализующий) указанный класс (интерфейс).
    </li><li>
        Сгенерированный класс должен компилироваться без ошибок.
    </li><li>
        Сгенерированный класс не должен быть абстрактным.
    </li><li>
        Методы сгенерированного класса должны игнорировать свои аргументы и
        возвращать значения по умолчанию.
    </li></ul></li><li>
    В задании выделяются три варианта:
    <ul><li><em>Простой</em> &mdash; <code>Implementor</code> должен уметь реализовывать
        только интерфейсы (но не классы). Поддержка generics не требуется.
    </li><li><em>Сложный</em> &mdash; <code>Implementor</code> должен уметь реализовывать
        и классы, и интерфейсы. Поддержка generics не требуется.
    </li><li><em>Бонусный</em> &mdash; <code>Implementor</code> должен уметь реализовывать
        generic-классы и интерфейсы. Сгенерированный код должен иметь
        корректные параметры типов и не порождать <code>UncheckedWarning</code>.
    </li></ul></li></ol><h3 id="homework-implementor-jar">Домашнее задание 5. Jar Implementor</h3><ol><li>
    Создайте <code>.jar</code>-файл, содержащий скомпилированный
    <code>Implementor</code> и сопутствующие классы.
    <ul><li>
        Созданный <code>.jar</code>-файл должен запускаться командой
        <code>java -jar</code>.
    </li><li>
        Запускаемый <code>.jar</code>-файл должен принимать те же аргументы командной
        строки, что и класс <code>Implementor</code>.
    </li></ul></li><li>
    Модифицируйте <code>Implemetor</code> так, чтобы
    при запуске с аргументами <code>-jar имя-класса файл.jar</code>
    он генерировал <code>.jar</code>-файл с реализацией
    соответствующего класса (интерфейса).
</li><li>
    Для проверки, кроме исходного кода так же должны быть представлены:
    <ul><li>
        скрипт для создания запускаемого <code>.jar</code>-файла,
        в том числе, исходный код манифеста;
    </li><li>
        запускаемый <code>.jar</code>-файл.
    </li></ul></li><li>
    Данное домашнее задание сдается только вместе с предыдущим.
    Предыдущее домашнее задание отдельно сдать будет нельзя.
</li><li><b>Сложный вариант</b>. Решение должно быть модуляризовано.
</li></ol><h3 id="homework-implementor-javadoc">Домашнее задание 6. Javadoc</h3><ol><li>
    Документируйте класс <code>Implementor</code> и сопутствующие классы
    с применением Javadoc.
    <ul><li>
        Должны быть документированы все классы и все члены классов,
        в том числе <code>private</code>.
    </li><li>
        Документация должна генерироваться без предупреждений.
    </li><li>
        Сгенерированная документация должна содержать корректные
        ссылки на классы стандартной библиотеки.
    </li></ul></li><li>
    Для проверки, кроме исходного кода так же должны быть представлены:
    <ul><li>
        скрипт для генерации документации;
    </li><li>
        сгенерированная документация.
    </li></ul></li><li>
    Данное домашнее задание сдается только вместе с предыдущим.
    Предыдущее домашнее задание отдельно сдать будет нельзя.
</li></ol><h3 id="homework-concurrent">Домашнее задание 7. Итеративный параллелизм</h3><ol><li>
    Реализуйте класс <tt>IterativeParallelism</tt>,
    который будет обрабатывать списки в несколько потоков.
</li><li>
    В простом варианте должны быть реализованы следующие методы:
    <ul><li><tt>minimum(threads, list, comparator)</tt> &mdash;
        первый минимум;
    </li><li><tt>maximum(threads, list, comparator)</tt> &mdash;
        первый максимум;
    </li><li><tt>all(threads, list, predicate)</tt> &mdash;
        проверка, что все элементы списка удовлетворяют предикату;
    </li><li><tt>any(threads, list, predicate)</tt> &mdash;
        проверка, что существует элемент списка, удовлетворяющий предикату.
    </li></ul></li><li>
    В сложном варианте должны быть дополнительно реализованы следующие методы:
    <ul><li><tt>filter(threads, list, predicate)</tt> &mdash;
        вернуть список, содержащий элементы удовлетворяющие предикату;
    </li><li><tt>map(threads, list, function)</tt> &mdash;
        вернуть список, содержащий результаты применения функции;
    </li><li><tt>join(threads, list)</tt> &mdash;
        конкатенация строковых представлений элементов списка.
    </li></ul></li><li>
    Во все функции передается параметр <tt>threads</tt> &mdash;
    сколько потоков надо использовать при вычислении.
    Вы можете рассчитывать, что число потоков не велико.
</li><li>
    Не следует рассчитывать на то, что переданные компараторы,
    предикаты и функции работают быстро.
</li><li>
    При выполнении задания <strong>нельзя</strong> использовать
    <i>Concurrency Utilities</i>.
</li><li>
    Рекомендуется подумать, какое отношение к
    заданию имеют <a href="https://en.wikipedia.org/wiki/Monoid">моноиды</a>.
</li></ol><h3 id="homework-mapper">Домашнее задание 8. Параллельный запуск</h3><ol><li>
    Напишите класс <tt>ParallelMapperImpl</tt>, реализующий интерфейс
    <tt>ParallelMapper</tt>.
    <pre>
public interface ParallelMapper extends AutoCloseable {
    &lt;T, R&gt; List&lt;R&gt; map(
        Function&lt;? super T, ? extends R&gt; f,
        List&lt;? extends T&gt; args
    ) throws InterruptedException;

    @Override
    void close() throws InterruptedException;
}
</pre><ul><li>
    Метод <tt>run</tt> должен параллельно вычислять
    функцию <tt>f</tt> на каждом из указанных аргументов
    (<tt>args</tt>).
</li><li>
    Метод <tt>close</tt> должен останавливать все рабочие потоки.
</li><li>
    Конструктор <tt>ParallelMapperImpl(int threads)</tt>
    создает <tt>threads</tt> рабочих потоков, которые могут
    быть использованы для распараллеливания.
</li><li>
    К одному <tt>ParallelMapperImpl</tt> могут одновременно обращаться
    несколько клиентов.
</li><li>
    Задания на исполнение должны накапливаться в очереди и обрабатываться
    в порядке поступления.
</li><li>
    В реализации не должно быть активных ожиданий.
</li></ul></li><li>
    Доработайте класс <tt>IterativeParallelism</tt> так,
    чтобы он мог использовать <tt>ParallelMapper</tt>.
    <ul><li>
        Добавьте конструктор <tt>IterativeParallelism(ParallelMapper)</tt></li><li>
        Методы класса должны делить работу на <tt>threads</tt>
        фрагментов и исполнять их при помощи <tt>ParallelMapper</tt>.
    </li><li>
        При наличии <tt>ParallelMapper</tt> сам
        <tt>IterativeParallelism</tt> новые потоки создавать не должен.
    </li><li>
        Должна быть возможность одновременного запуска и работы
        нескольких клиентов, использующих один <tt>ParallelMapper</tt>.
    </li></ul></li></ol><h3 id="homework-crawler">Домашнее задание 9. Web Crawler</h3><ol><li>
    Напишите потокобезопасный класс <code>WebCrawler</code>, который
    будет рекурсивно обходить сайты.
    <ol><li>
        Класс <code>WebCrawler</code> должен иметь конструктор
        <pre>
public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
                    </pre><ul><li><code>downloader</code> позволяет скачивать страницы и
        извлекать из них ссылки;
    </li><li><code>downloaders</code> &mdash; максимальное число
        одновременно загружаемых страниц;
    </li><li><code>extractors</code> &mdash; максимальное число страниц,
        из которых одновременно извлекаются ссылки;
    </li><li><code>perHost</code> &mdash; максимальное число страниц,
        одновременно загружаемых c одного хоста.
        Для определения хоста следует использовать
        метод <code>getHost</code> класса
        <code>URLUtils</code> из тестов.
    </li></ul></li><li>
        Класс <code>WebCrawler</code> должен реализовывать интерфейс
        <code>Crawler</code><pre>
public interface Crawler extends AutoCloseable {
    Result download(String url, int depth);

    void close();
}
                    </pre><ul><li>
        Метод <code>download</code> должен рекурсивно обходить страницы,
        начиная с указанного URL на указанную глубину и
        возвращать список загруженных страниц и файлов.

        Например, если глубина равна 1, то должна быть
        загружена только указанная страница. Если глубина равна
        2, то указанная страница и те страницы и файлы, на которые
        она ссылается и так далее.

        Этот метод может вызываться параллельно в нескольких потоках.
    </li><li>
        Загрузка и обработка страниц (извлечение ссылок)
        должна выполняться максимально параллельно,
        с учетом ограничений на число одновременно
        загружаемых страниц (в том числе с одного хоста)
        и страниц, с которых загружаются ссылки.
    </li><li>
        Для распараллеливания разрешается создать
        до <code>downloaders + extractors</code>
        вспомогательных потоков.
    </li><li>
        Загружать и/или извлекать ссылки из одной
        и той же страницы в рамках одного обхода
        (<code>download</code>) запрещается.
    </li><li>
        Метод <code>close</code> должен завершать все
        вспомогательные потоки.
    </li></ul></li><li>
        Для загрузки страниц должен применяться <code>Downloader</code>,
        передаваемый первым аргументом конструктора.
        <pre>
public interface Downloader {
    public Document download(final String url) throws IOException;
}
                    </pre><ul><li>
        Метод <code>download</code> загружает документ по его адресу
        (<a href="http://tools.ietf.org/html/rfc3986">URL</a>).
    </li><li>
        Документ позволяет получить ссылки по загруженной странице:
        <pre>
public interface Document {
    List&lt;String&gt; extractLinks() throws IOException;
}
                            </pre>
        Ссылки, возвращаемые документом, являются абсолютными
        и имеют схему <code>http</code> или <code>https</code>.
    </li></ul></li><li>
        Должен быть реализован метод <code>main</code>,
        позволяющий запустить обход из командной строки
        <ul><li>
            Командная строка
            <pre>
WebCrawler url [depth [downloads [extractors [perHost]]]]
                            </pre></li><li>
            Для загрузки страниц требуется использовать реализацию
            <code>CachingDownloader</code> из тестов.
        </li></ul></li></ol></li><li>
    Версии задания
    <ol><li><em>Простая</em> &mdash; не требуется учитывать ограничения
        на число одновременных закачек с одного хоста
        (<code>perHost &gt;= downloaders</code>).
    </li><li><em>Полная</em> &mdash; требуется учитывать все ограничения.
    </li><li><em>Бонусная</em> &mdash; сделать параллельный обод в ширину.
    </li></ol></li></ol><h3 id="homework-hello-udp">Домашнее задание 10. HelloUDP</h3><ol><li>
    Реализуйте клиент и сервер, взаимодействующие по UDP.
</li><li>
    Класс <tt>HelloUDPClient</tt> должен отправлять запросы
    на сервер, принимать результаты и выводить их на консоль.
    <ul><li>
        Аргументы командной строки:
        <ol><li>имя или ip-адрес компьютера, на котором запущен сервер;</li><li>номер порта, на который отсылать запросы;</li><li>префикс запросов (строка);</li><li>число параллельных потоков запросов;</li><li>число запросов в каждом потоке.</li></ol></li><li>
        Запросы должны одновременно отсылаться в указанном числе потоков.
        Каждый поток должен ожидать обработки своего запроса и выводить
        сам запрос и результат его обработки на консоль.
        Если запрос не был обработан, требуется послать его заново.
    </li><li>
        Запросы должны формироваться по схеме
        <tt>&lt;префикс запросов&gt;&lt;номер потока&gt;_&lt;номер запроса в потоке&gt;</tt>.
    </li></ul></li><li>
    Класс <tt>HelloUDPServer</tt> должен принимать задания, отсылаемые
    классом <tt>HelloUDPClient</tt> и отвечать на них.
    <ul><li>
        Аргументы командной строки:
        <ol><li>номер порта, по которому будут приниматься запросы;</li><li>число рабочих потоков, которые будут обрабатывать запросы.</li></ol></li><li>
        Ответом на запрос должно быть <tt>Hello, &lt;текст запроса&gt;</tt>.
    </li><li>
        Если сервер не успевает обрабатывать запросы, прием запросов может
        быть временно приостановлен.
    </li></ul></li></ol><h3 id="homework-bank">Домашнее задание 11. Физические лица</h3><ol><li>
    Добавьте к банковскому приложению возможность работы с физическими
    лицами.
    <ol><li>
        У физического лица (<code>Person</code>) можно запросить имя, фамилию и номер паспорта.
    </li><li>
        Локальные физические лица (<code>LocalPerson</code>) должны передаваться при помощи
        механизма сериализации.
    </li><li>
        Удалённые физические лица (<code>RemotePerson</code>) должны передаваться при помощи
        удалённых объектов.
    </li><li>
        Должна быть возможность поиска физического лица по
        номеру паспорта, с выбором типа возвращаемого лица.
    </li><li>
        Должна быть возможность создания записи о физическом лице по его данным.
    </li><li>
        У физического лица может быть несколько счетов, к которым должен
        предоставляться доступ.
    </li><li>
        Счету физического лица с идентификатором <var>subId</var>
        должен соответствовать банковский счет с <var>id</var>
        вида <var>passport</var>:<var>subId</var>.
    </li><li>
        Изменения, производимые со счетом в банке
        (создание и изменение баланса), должны быть видны всем
        соответствующим <code>RemotePerson</code>, и только тем
        <code>LocalPerson</code>, которые были созданы после этого изменения.
    </li><li>
        Изменения в счетах, производимые через <code>RemotePerson</code>,
        должны сразу применяться глобально, а производимые
        через <code>LocalPerson</code> &ndash; только локально
        для этого конкретного <code>LocalPerson</code>.
    </li></ol></li><li>
    Реализуйте приложение, демонстрирующее работу с физическим лицами.
    <ol><li>
        Аргументы командной строки: имя, фамилия, номер паспорта физического
        лица, номер счета, изменение суммы счета.
    </li><li>
        Если информация об указанном физическом лице отсутствует, то оно должно
        быть добавлено. В противном случае &ndash; должны быть проверены его данные.
    </li><li>
        Если у физического лица отсутствует счет с указанным номером, то
        он создается с нулевым балансом.
    </li><li>
        После обновления суммы счета новый баланс должен выводиться на консоль.
    </li></ol></li><li>
    Напишите тесты, проверяющее вышеуказанное поведение как банка, так и приложения.
    <ul><li>
        Для реализации тестов рекомендуется использовать
        <a href="https://junit.org/junit5/">JUnit</a>
        (<a href="https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-our-first-test-class/">Tutorial</a>).
        Множество примеров использования можно найти в тестах.
    </li><li>
        Если вы знакомы с другим тестовым фреймворком
        (например, <a href="https://testng.org/">TestNG</a>),
        то можете использовать его.
    </li><li>
        Jar-файлы используемых библиотек надо класть в каталог
        <code>lib</code> вашего репозитория.
    </li><li>
        Использовать самописные фреймворки и тесты запускаемые
        через <code>main</code> нельзя.
    </li></ul></li><li><b>Сложный вариант</b><ol><li>
    Тесты не должны рассчитывать на наличие запущенного
    RMI Registry.
</li><li>
    Создайте класс <code>BankTests</code>, запускающий тесты.
</li><li>
    Создайте скрипт, запускающий <code>BankTests</code>
    и возвращающий код (статус) <code>0</code>
    в случае успеха и <code>1</code> в случае неудачи.
</li><li>
    Создайте скрипт, запускающий тесты с использованием
    стандартного подхода для вашего тестового фреймворка.
    Код возврата должен быть как в предыдущем пункте.
</li></ol></li></ol><h3 id="homework-hello-nio">Домашнее задание 12. HelloNonblockingUDP</h3><ol><li>
    Реализуйте клиент и сервер, взаимодействующие по UDP,
    используя только неблокирующий ввод-вывод.
</li><li>
    Класс <code>HelloUDPNonblockingClient</code> должен
    иметь функциональность аналогичную <code>HelloUDPClient</code>,
    но без создания новых потоков.
</li><li>
    Класс <code>HelloUDPNonblockingServer</code> должен
    иметь функциональность аналогичную <code>HelloUDPServer</code>,
    но все операции с сокетом должны производиться в одном потоке.
</li><li>
    В реализации не должно быть активных ожиданий,
    в том числе через <code>Selector</code>.
</li><li>
    Обратите внимание на выделение общего кода старой и новой реализации.
</li><li><em>Бонусный вариант</em>.
    Клиент и сервер могут перед началом работы выделить
    O(число потоков) памяти.
    Выделять дополнительную память во время работы запрещено.
</li></ol><h3 id="homework-test-stats">Домашнее задание 13. Статистика текста</h3><ol><li>
    Создайте приложение <code>TextStatistics</code>,
    анализирующее тексты на различных языках.
    <ol><li>
        Аргументы командной строки:
        <ul><li>локаль текста,</li><li>локаль вывода,</li><li>файл с текстом,</li><li>файл отчета.</li></ul></li><li>
        Поддерживаемые локали текста: все локали, имеющиеся в системе.
    </li><li>
        Поддерживаемые локали вывода: русская и английская.
    </li><li>
        Файлы имеют кодировку UTF-8.
    </li><li>
        Подсчет статистики должен вестись по следующим категориям:
        <ul><li>предложения,</li><li>слова,</li><li>числа,</li><li>деньги,</li><li>даты.</li></ul></li><li>
        Для каждой категории должна собираться следующая статистика:
        <ul><li>число вхождений,</li><li>число различных значений,</li><li>минимальное значение,</li><li>максимальное значение,</li><li>минимальная длина,</li><li>максимальная длина,</li><li>среднее значение/длина.</li></ul></li><li>
        Пример отчета:
        <pre>
Анализируемый файл "input.txt"
Сводная статистика
    Число предложений: 43.
    Число слов: 275.
    Число чисел: 40.
    Число сумм: 3.
    Число дат: 3.
Статистика по предложениям
    Число предложений: 43 (43 различных).
    Минимальное предложение: "Аргументы командной строки: локаль текста, локаль вывода, файл с текстом, файл отчета.".
    Максимальное предложение: "Число чисел: 40.".
    Минимальная длина предложения: 13 ("Число дат: 3.").
    Максимальная длина предложения: 211 ("GK: если сюда поставить реальное предложение, то процесс не сойдётся").
    Средняя длина предложения: 55,465.
Статистика по словам
    Число слов: 275 (157 различных).
    Минимальное слово: "GK".
    Максимальное слово: "языках".
    Минимальная длина слова: 1 ("с").
    Максимальная длина слова: 14 ("TextStatistics").
    Средняя длина слова: 6,72.
Статистика по числам
    Число чисел: 40 (24 различных).
    Минимальное число: -12345,0.
    Максимальное число: 12345,67.
    Среднее число: 207,676.
Статистика по суммам денег
    Число сумм: 3 (3 различных).
    Минимальная сумма: 100,00&nbsp;₽.
    Максимальная сумма: 345,67&nbsp;₽.
    Средняя сумма: 222,83&nbsp;₽.
Статистика по датам
    Число дат: 3 (3 различных).
    Минимальная дата: 22 мая 2021 г..
    Максимальная дата: 8 июн. 2021 г..
    Средняя дата: 30 мая 2021 г..
</pre></li></ol></li><li>
    Вы можете рассчитывать на то, что весь текст помещается в память.
</li><li>
    При выполнении задания следует обратить внимание на:
    <ol><li>Декомпозицию сообщений для локализации</li><li>Согласование сообщений по роду и числу</li></ol></li><li>
    Напишите тесты, проверяющее вышеуказанное поведение приложения.
    <ul><li>
        Для реализации тестов рекомендуется использовать
        <a href="https://junit.org/junit5/">JUnit</a>
        (<a href="https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-our-first-test-class/">Tutorial</a>).
        Множество примеров использования можно найти в тестах.
    </li><li>
        Если вы знакомы с другим тестовым фреймворком
        (например, <a href="https://testng.org/">TestNG</a>),
        то можете использовать его.
    </li><li>
        Использовать самописные фреймворки и тесты запускаемые
        через <code>main</code> нельзя.
    </li></ul></li></ol></td><td id="sidebar"><div id="sidebar-head"><form method="get" action="https://www.google.com/search"><p><input type="hidden" name="sitesearch" value="kgeorgiy.info"></p><table><tr><td style="width:100%"><input style="width:100%" type="text" name="q" maxlength="255"></td><td><button type="submit" value="Search"><img alt="Search" src="/design/find.png" width="16" height="16"></button></td></tr></table></form></div><div id="sidebar-body"><h3><a href="#homework-walk">Домашнее задание 1. Обход файлов</a></h3><h3><a href="#homework-arrayset">Домашнее задание 2. Множество на массиве</a></h3><h3><a href="#homework-student">Домашнее задание 3. Студенты</a></h3><h3><a href="#homework-implementor">Домашнее задание 4. Implementor</a></h3><h3><a href="#homework-implementor-jar">Домашнее задание 5. Jar Implementor</a></h3><h3><a href="#homework-implementor-javadoc">Домашнее задание 6. Javadoc</a></h3><h3><a href="#homework-concurrent">Домашнее задание 7. Итеративный параллелизм</a></h3><h3><a href="#homework-mapper">Домашнее задание 8. Параллельный запуск</a></h3><h3><a href="#homework-crawler">Домашнее задание 9. Web Crawler</a></h3><h3><a href="#homework-hello-udp">Домашнее задание 10. HelloUDP</a></h3><h3><a href="#homework-bank">Домашнее задание 11. Физические лица</a></h3><h3><a href="#homework-hello-nio">Домашнее задание 12. HelloNonblockingUDP</a></h3><h3><a href="#homework-test-stats">Домашнее задание 13. Статистика текста</a></h3></div><div id="sidebar-foot"><a href="https://validator.w3.org/check?uri=referer"><img src="https://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></a></div></td></tr></table><script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter19426939 = new Ya.Metrika({
                    id:19426939,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script><noscript><div><img src="https://mc.yandex.ru/watch/19426939" style="position:absolute; left:-9999px;" alt=""></div></noscript></body></html>